<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
<title>Responsive Two-Player 8-Ball Pool</title>
<style>
  /* Reset and base */
  * {
    box-sizing: border-box;
  }
  html, body {
    margin: 0; padding: 0;
    height: 100%;
    background: #18153a;
    display: flex;
    justify-content: center;
    align-items: center;
    font-family: 'Arial', sans-serif;
    user-select: none;
  }
  #game-container {
    position: relative;
    width: 90vw;
    max-width: 600px;
    aspect-ratio: 16 / 9;
    background: linear-gradient(145deg, #3ac6ff 60%, #0d47a1 100%);
    border-radius: 22px;
    box-shadow: 0 0 30px 8px #2196f3, 0 6px 24px #000a;
    border: 7px solid #25c6fc;
    overflow: hidden;
  }
  #pool-table {
    position: relative;
    width: 100%;
    height: 100%;
  }
  /* Pockets */
  .pocket {
    position: absolute;
    width: 4.5vw;
    height: 4.5vw;
    max-width: 28px;
    max-height: 28px;
    border-radius: 50%;
    background: radial-gradient(circle at 60% 40%, #222 60%, #000 100%);
    box-shadow: 0 0 18px #000b, 0 0 0 4px #1b1836;
    z-index: 2;
  }
  .pocket.tl { left: -1.2vw; top: -1.2vw; }
  .pocket.tr { right: -1.2vw; top: -1.2vw; }
  .pocket.bl { left: -1.2vw; bottom: -1.2vw; }
  .pocket.br { right: -1.2vw; bottom: -1.2vw; }
  .pocket.tc { left: 50%; top: -1.2vw; transform: translateX(-50%);}
  .pocket.bc { left: 50%; bottom: -1.2vw; transform: translateX(-50%);}
  /* Logo */
  #logo {
    position: absolute;
    top: 5%;
    left: 50%;
    transform: translateX(-50%);
    font-family: 'Luckiest Guy', cursive;
    font-size: 3vw;
    color: #e0f6ff;
    letter-spacing: 0.8vw;
    text-shadow: 0 3px 10px #0008, 0 1px 0 #2196f3;
    user-select: none;
    pointer-events: none;
    z-index: 3;
    display: flex;
    align-items: center;
  }
  #logo .eight-ball {
    width: 4vw;
    height: 4vw;
    border-radius: 50%;
    background: radial-gradient(circle at 60% 40%, #444 55%, #111 100%);
    margin: 0 0.5vw;
    box-shadow: 0 0 10px #000a, 0 4px 10px #0008;
    position: relative;
    display: flex;
    justify-content: center;
    align-items: center;
  }
  #logo .eight-ball span {
    color: #fff;
    font-weight: bold;
    font-size: 2vw;
    text-shadow: 0 2px 4px #000a;
  }
  /* Balls */
  .ball {
    position: absolute;
    width: 3.5vw;
    height: 3.5vw;
    max-width: 22px;
    max-height: 22px;
    border-radius: 50%;
    box-shadow: 0 2px 8px #000a, 0 0 0 2px #fff3;
    border: 2px solid #fff8;
    z-index: 4;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: bold;
    font-family: Arial, sans-serif;
    user-select: none;
    transition: none;
  }
  .ball.cue { background: radial-gradient(circle at 60% 40%, #fff 80%, #e0e0e0 100%);}
  .ball.eight {
    background: radial-gradient(circle at 60% 40%, #444 70%, #111 100%);
    color: #fff;
    font-size: 1.2vw;
    text-shadow: 0 2px 4px #000a;
  }
  .ball.red { background: radial-gradient(circle at 60% 40%, #ff4b4b 70%, #a60000 100%);}
  .ball.yellow { background: radial-gradient(circle at 60% 40%, #ffe44b 70%, #bba600 100%);}
  .ball.blue { background: radial-gradient(circle at 60% 40%, #4b7bff 70%, #0033a6 100%);}
  .ball.green { background: radial-gradient(circle at 60% 40%, #4bff7b 70%, #00a64b 100%);}
  .ball.purple { background: radial-gradient(circle at 60% 40%, #c44bff 70%, #6a00a6 100%);}
  .ball.orange { background: radial-gradient(circle at 60% 40%, #ffb84b 70%, #a66a00 100%);}
  /* Cue stick */
  #cue-stick {
    position: absolute;
    width: 12vw;
    max-width: 210px;
    height: 0.5vw;
    max-height: 7px;
    left: 13vw;
    top: 51%;
    background: linear-gradient(90deg, #ffb84b 0%, #d48a1b 60%, #333 100%);
    border-radius: 4px;
    box-shadow: 0 2px 8px #000a;
    z-index: 10;
    transform-origin: 2.5vw 50%;
    cursor: pointer;
    user-select: none;
    pointer-events: auto;
    transition: box-shadow 0.15s;
  }
  #cue-stick .cue-tip {
    position: absolute;
    left: 0; top: 0.07vw;
    width: 1.8vw;
    max-width: 28px;
    height: 0.3vw;
    max-height: 5px;
    background: linear-gradient(90deg, #eee 60%, #2196f3 100%);
    border-radius: 3px 0 0 3px;
    box-shadow: 1px 0 3px #2196f3;
  }
  /* Message */
  #message {
    position: absolute;
    top: 1vw;
    width: 100%;
    text-align: center;
    color: #fff;
    font-size: 1.3vw;
    text-shadow: 0 2px 8px #000b;
    z-index: 100;
    pointer-events: none;
  }
  /* Confetti */
  #confetti {
    position: fixed;
    top: 0; left: 0;
    width: 100vw; height: 100vh;
    pointer-events: none;
    z-index: 1000;
  }
</style>
</head>
<body>
<div id="game-container">
  <div id="pool-table">
    <div class="pocket tl"></div>
    <div class="pocket tr"></div>
    <div class="pocket bl"></div>
    <div class="pocket br"></div>
    <div class="pocket tc"></div>
    <div class="pocket bc"></div>
    <div id="logo">
      P<span class="eight-ball"><span>8</span></span>OL
    </div>
    <div id="cue-stick"><div class="cue-tip"></div></div>
    <canvas id="aimCanvas"></canvas>
    <div id="message"></div>
  </div>
</div>
<canvas id="confetti"></canvas>

<script>
(() => {
  // Constants & Setup
  const container = document.getElementById('game-container');
  const table = document.getElementById('pool-table');
  const msg = document.getElementById('message');
  const cueStick = document.getElementById('cue-stick');
  const aimCanvas = document.getElementById('aimCanvas');
  const aimCtx = aimCanvas.getContext('2d');
  const confettiCanvas = document.getElementById('confetti');
  const confettiCtx = confettiCanvas.getContext('2d');

  const BALL_RADIUS_PX = 22; // max ball size in px for calculations
  const BALL_RADIUS = 11; // half of ball size in px
  const FRICTION = 0.98;
  const MIN_VELOCITY = 0.05;
  const POCKET_RADIUS = 28;

  // Responsive sizing helpers
  function resize() {
    const rect = table.getBoundingClientRect();
    aimCanvas.width = rect.width;
    aimCanvas.height = rect.height;
    aimCanvas.style.width = rect.width + 'px';
    aimCanvas.style.height = rect.height + 'px';

    confettiCanvas.width = window.innerWidth;
    confettiCanvas.height = window.innerHeight;
  }
  window.addEventListener('resize', resize);
  resize();

  // Pocket positions (relative to table)
  function getPocketPositions() {
    const rect = table.getBoundingClientRect();
    return [
      {x: 0, y: 0},
      {x: rect.width/2, y: 0},
      {x: rect.width, y: 0},
      {x: 0, y: rect.height},
      {x: rect.width/2, y: rect.height},
      {x: rect.width, y: rect.height}
    ];
  }

  // Ball class
  class Ball {
    constructor(id, group, color, number, x, y) {
      this.id = id;
      this.group = group; // 'cue', 'solids', 'stripes', 'eight'
      this.color = color;
      this.number = number;
      this.x = x;
      this.y = y;
      this.vx = 0;
      this.vy = 0;
      this.pocketed = false;

      this.el = document.createElement('div');
      this.el.classList.add('ball');
      if (this.group === 'cue') this.el.classList.add('cue');
      else if (this.group === 'eight') this.el.classList.add('eight');
      else this.el.classList.add(this.color);

      if (this.number > 0) this.el.textContent = this.number;

      table.appendChild(this.el);
      this.updatePosition();
    }
    updatePosition() {
      this.el.style.left = (this.x - BALL_RADIUS) + 'px';
      this.el.style.top = (this.y - BALL_RADIUS) + 'px';
      this.el.style.display = this.pocketed ? 'none' : 'flex';
    }
    move() {
      if (this.pocketed) return;
      this.x += this.vx;
      this.y += this.vy;

      const leftBound = BALL_RADIUS;
      const rightBound = table.clientWidth - BALL_RADIUS;
      const topBound = BALL_RADIUS;
      const bottomBound = table.clientHeight - BALL_RADIUS;

      if (this.x < leftBound) {
        this.x = leftBound;
        this.vx = -this.vx * 0.9;
      }
      if (this.x > rightBound) {
        this.x = rightBound;
        this.vx = -this.vx * 0.9;
      }
      if (this.y < topBound) {
        this.y = topBound;
        this.vy = -this.vy * 0.9;
      }
      if (this.y > bottomBound) {
        this.y = bottomBound;
        this.vy = -this.vy * 0.9;
      }

      this.vx *= FRICTION;
      this.vy *= FRICTION;

      if (Math.abs(this.vx) < MIN_VELOCITY) this.vx = 0;
      if (Math.abs(this.vy) < MIN_VELOCITY) this.vy = 0;

      this.updatePosition();
    }
    isMoving() {
      return Math.abs(this.vx) > 0 || Math.abs(this.vy) > 0;
    }
  }

  // Utility functions
  function dist(x1, y1, x2, y2) {
    return Math.hypot(x1 - x2, y1 - y2);
  }

  function resolveCollision(b1, b2) {
    if (b1.pocketed || b2.pocketed) return;

    const dx = b2.x - b1.x;
    const dy = b2.y - b1.y;
    const distance = Math.hypot(dx, dy);
    if (distance === 0) return;

    if (distance < BALL_RADIUS * 2) {
      const overlap = BALL_RADIUS * 2 - distance;
      const nx = dx / distance;
      const ny = dy / distance;

      b1.x -= nx * overlap / 2;
      b1.y -= ny * overlap / 2;
      b2.x += nx * overlap / 2;
      b2.y += ny * overlap / 2;

      const tx = -ny;
      const ty = nx;

      const v1n = b1.vx * nx + b1.vy * ny;
      const v1t = b1.vx * tx + b1.vy * ty;
      const v2n = b2.vx * nx + b2.vy * ny;
      const v2t = b2.vx * tx + b2.vy * ty;

      const v1nAfter = v2n;
      const v2nAfter = v1n;

      b1.vx = v1nAfter * nx + v1t * tx;
      b1.vy = v1nAfter * ny + v1t * ty;
      b2.vx = v2nAfter * nx + v2t * tx;
      b2.vy = v2nAfter * ny + v2t * ty;
    }
  }

  function checkPocket(ball) {
    if (ball.pocketed) return false;
    const pockets = getPocketPositions();
    for (const p of pockets) {
      if (dist(ball.x, ball.y, p.x, p.y) < POCKET_RADIUS) {
        return true;
      }
    }
    return false;
  }

  function pocketBall(ball) {
    ball.pocketed = true;
    ball.vx = 0;
    ball.vy = 0;
    ball.updatePosition();
  }

  // Game state variables
  let balls = [];
  let currentPlayer = 1;
  let playerGroups = {1: null, 2: null};
  let ballsPocketed = {solids: 0, stripes: 0};
  const ballsPerGroup = 7;
  let gameOver = false;
  let cueBallInHand = false;
  let ballsMoving = false;
  let pocketedThisShot = [];
  let cueBallScratch = false;

  // Cue ball start position
  let cueStartX, cueStartY;

  // Initialize balls with relative positions scaled to container size
  function initBalls() {
    balls.forEach(b => b.el.remove());
    balls = [];

    const rect = table.getBoundingClientRect();
    cueStartX = rect.width * 0.4;
    cueStartY = rect.height * 0.6;

    // Cue ball
    balls.push(new Ball(0, 'cue', 'cue', 0, cueStartX, cueStartY));

    // Rack balls arranged in triangle
    const rackX = rect.width * 0.7;
    const rackY = rect.height * 0.5;
    const rowHeight = BALL_RADIUS * Math.sqrt(3);

    // Balls order for rack
    const rackBallsInfo = [
      {number: 1, group: 'solids', color: 'red'},
      {number: 14, group: 'stripes', color: 'blue'},
      {number: 7, group: 'solids', color: 'brown'},
      {number: 9, group: 'stripes', color: 'red'},
      {number: 8, group: 'eight', color: 'eight'},
      {number: 3, group: 'solids', color: 'green'},
      {number: 13, group: 'stripes', color: 'purple'},
      {number: 2, group: 'solids', color: 'yellow'},
      {number: 12, group: 'stripes', color: 'orange'},
      {number: 6, group: 'solids', color: 'blue'},
      {number: 11, group: 'stripes', color: 'green'},
      {number: 5, group: 'solids', color: 'purple'},
      {number: 10, group: 'stripes', color: 'yellow'},
      {number: 4, group: 'solids', color: 'orange'},
      {number: 15, group: 'stripes', color: 'brown'}
    ];

    let ballIndex = 0;
    for (let row = 0; row < 5; row++) {
      const ballsInRow = row + 1;
      const y = rackY + row * rowHeight;
      const rowWidth = ballsInRow * BALL_RADIUS * 2;
      const startX = rackX - rowWidth / 2 + BALL_RADIUS;
      for (let col = 0; col < ballsInRow; col++) {
        if (ballIndex >= rackBallsInfo.length) break;
        const x = startX + col * BALL_RADIUS * 2;
        const info = rackBallsInfo[ballIndex];
        balls.push(new Ball(info.number, info.group, info.color, info.number, x, y));
        ballIndex++;
      }
    }
  }

  // Game logic functions
  function switchTurn() {
    currentPlayer = currentPlayer === 1 ? 2 : 1;
  }

  function enableCueBallPlacement() {
    showMessage(`Player ${currentPlayer}, place the cue ball.`);
    cueStick.style.display = 'none';
    cueBallInHand = true;
  }

  function disableCueBallPlacement() {
    cueBallInHand = false;
    cueStick.style.display = 'block';
  }

  function updateCueStick(angle) {
    const cueBall = balls.find(b => b.group === 'cue');
    if (!cueBall || cueBall.pocketed) return;
    const ballX = cueBall.x;
    const ballY = cueBall.y;
    const gap = BALL_RADIUS * 3.5;
    const stickX = ballX - Math.cos(angle) * gap;
    const stickY = ballY - Math.sin(angle) * gap;
    cueStick.style.left = (stickX - cueStick.offsetWidth * 0.15) + 'px';
    cueStick.style.top = (stickY - cueStick.offsetHeight / 2) + 'px';
    cueStick.style.transform = `rotate(${angle * 180 / Math.PI}deg)`;
  }

  function shoot(power, angle) {
    if (ballsMoving || gameOver || cueBallInHand) return;
    const cueBall = balls.find(b => b.group === 'cue');
    if (!cueBall || cueBall.pocketed) return;
    cueBall.vx = Math.cos(angle) * power;
    cueBall.vy = Math.sin(angle) * power;
    ballsMoving = true;
    pocketedThisShot = [];
    cueBallScratch = false;
    cueStick.style.display = 'none';
  }

  // Aiming variables
  let isAiming = false;
  let aimStart = null;
  let aimCurrent = null;

  function updateAimVisual() {
    aimCtx.clearRect(0, 0, aimCanvas.width, aimCanvas.height);
    if (!isAiming) return;
    aimCtx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
    aimCtx.lineWidth = 3;
    aimCtx.beginPath();
    aimCtx.moveTo(aimStart.x, aimStart.y);
    aimCtx.lineTo(aimCurrent.x, aimCurrent.y);
    aimCtx.stroke();

    const angle = Math.atan2(aimStart.y - aimCurrent.y, aimStart.x - aimCurrent.x);
    updateCueStick(angle);
  }

  function clearAimVisual() {
    aimCtx.clearRect(0, 0, aimCanvas.width, aimCanvas.height);
  }

  function getPointerPos(e) {
    const rect = table.getBoundingClientRect();
    let clientX, clientY;
    if (e.touches) {
      clientX = e.touches[0].clientX;
      clientY = e.touches[0].clientY;
    } else {
      clientX = e.clientX;
      clientY = e.clientY;
    }
    return {
      x: clientX - rect.left,
      y: clientY - rect.top
    };
  }

  function onPointerDown(e) {
    if (ballsMoving || gameOver) return;
    if (cueBallInHand) {
      onCueBallPlace(e);
      return;
    }
    const pos = getPointerPos(e);
    const cueBall = balls.find(b => b.group === 'cue');
    if (!cueBall || cueBall.pocketed) return;
    if (dist(pos.x, pos.y, cueBall.x, cueBall.y) <= BALL_RADIUS * 1.5) {
      isAiming = true;
      aimStart = {x: cueBall.x, y: cueBall.y};
      aimCurrent = pos;
      updateAimVisual();
    }
  }

  function onPointerMove(e) {
    if (!isAiming) return;
    aimCurrent = getPointerPos(e);
    updateAimVisual();
  }

  function onPointerUp(e) {
    if (!isAiming) return;
    isAiming = false;
    clearAimVisual();
    const cueBall = balls.find(b => b.group === 'cue');
    if (!cueBall || cueBall.pocketed) return;

    const dx = aimStart.x - aimCurrent.x;
    const dy = aimStart.y - aimCurrent.y;
    const distance = dist(aimStart.x, aimStart.y, aimCurrent.x, aimCurrent.y);

    if (distance < 5) {
      showMessage(`Drag further to shoot.`);
      updateCueStick(0);
      return;
    }

    const maxPower = 15;
    const power = Math.min(distance / 10, maxPower);
    const angle = Math.atan2(dy, dx);

    shoot(power, angle);
  }

  function onCueBallPlace(e) {
    if (!cueBallInHand) return;
    const pos = getPointerPos(e);
    const leftBound = BALL_RADIUS;
    const rightBound = table.clientWidth - BALL_RADIUS;
    const topBound = BALL_RADIUS;
    const bottomBound = table.clientHeight - BALL_RADIUS;
    let x = Math.min(Math.max(pos.x, leftBound), rightBound);
    let y = Math.min(Math.max(pos.y, topBound), bottomBound);
    resetCueBallPosition(x, y);
    disableCueBallPlacement();
    showMessage(`Player ${currentPlayer}'s turn. Aim and shoot.`);
    updateCueStick(0);
  }

  function onShotEnd() {
    ballsMoving = false;

    if (pocketedThisShot.length === 0 && !cueBallScratch) {
      switchTurn();
      showMessage(`Player ${currentPlayer}'s turn`);
    } else {
      if (cueBallScratch) {
        showMessage(`Foul! Player ${currentPlayer} scratched. Player ${currentPlayer === 1 ? 2 : 1} ball in hand.`);
        switchTurn();
        cueBallInHand = true;
        enableCueBallPlacement();
      } else {
        if (!playerGroups[currentPlayer]) {
          const firstBall = pocketedThisShot[0];
          if (firstBall.group === 'solids' || firstBall.group === 'stripes') {
            playerGroups[currentPlayer] = firstBall.group;
            playerGroups[currentPlayer === 1 ? 2 : 1] = firstBall.group === 'solids' ? 'stripes' : 'solids';
            showMessage(`Player ${currentPlayer} is ${playerGroups[currentPlayer]}. Player ${currentPlayer === 1 ? 2 : 1} is ${playerGroups[currentPlayer === 1 ? 2 : 1]}. Player ${currentPlayer} continues.`);
          }
        }

        let pocketedOwnGroup = false;
        for (const ball of pocketedThisShot) {
          if (ball.group === playerGroups[currentPlayer]) {
            ballsPocketed[ball.group]++;
            pocketedOwnGroup = true;
          }
          if (ball.group === 'eight') {
            if (ballsPocketed[playerGroups[currentPlayer]] === ballsPerGroup) {
              gameOver = true;
              showMessage(`Player ${currentPlayer} wins! 🎉`);
              cueStick.style.display = 'none';
              startConfetti();
              return;
            } else {
              gameOver = true;
              showMessage(`Player ${currentPlayer} lost by pocketing 8-ball too early.`);
              cueStick.style.display = 'none';
              return;
            }
          }
        }

        if (pocketedOwnGroup) {
          showMessage(`Player ${currentPlayer} continues.`);
        } else {
          switchTurn();
          showMessage(`Player ${currentPlayer}'s turn.`);
        }
      }
    }

    pocketedThisShot = [];
    cueBallScratch = false;
    if (!gameOver && !cueBallInHand) cueStick.style.display = 'block';
  }

  function gameLoop() {
    if (!ballsMoving) {
      requestAnimationFrame(gameLoop);
      return;
    }

    balls.forEach(b => b.move());

    for (let i = 0; i < balls.length; i++) {
      for (let j = i + 1; j < balls.length; j++) {
        resolveCollision(balls[i], balls[j]);
      }
    }

    balls.forEach(ball => {
      if (!ball.pocketed && checkPocket(ball)) {
        pocketBall(ball);
        pocketedThisShot.push(ball);
        if (ball.group === 'cue') cueBallScratch = true;
      }
    });

    if (!ballsAreMoving()) {
      onShotEnd();
      if (!cueBallInHand && !gameOver) cueStick.style.display = 'block';
    }

    requestAnimationFrame(gameLoop);
  }

  // Confetti effect
  let confettiPieces = [];
  let confettiActive = false;
  function startConfetti() {
    confettiActive = true;
    createConfetti();
  }
  function createConfetti() {
    confettiPieces = [];
    for(let i=0;i<100;i++) {
      confettiPieces.push({
        x: Math.random()*confettiCanvas.width,
        y: Math.random()*confettiCanvas.height,
        r: Math.random()*6+4,
        c: `hsl(${Math.random()*360}, 100%, 70%)`,
        s: Math.random()*3+1,
        d: Math.random()*2*Math.PI
      });
    }
  }
  function drawConfetti() {
    confettiCtx.clearRect(0, 0, confettiCanvas.width, confettiCanvas.height);
    if (!confettiActive) return;
    for(let p of confettiPieces) {
      confettiCtx.save();
      confettiCtx.translate(p.x,p.y);
      confettiCtx.rotate(p.d);
      confettiCtx.fillStyle = p.c;
      confettiCtx.beginPath();
      confettiCtx.arc(0,0,p.r,0,2*Math.PI);
      confettiCtx.fill();
      confettiCtx.restore();
      p.y += p.s;
      p.x += Math.sin(p.d)*1.5;
      if(p.y > confettiCanvas.height) p.y = -10;
      if(p.x > confettiCanvas.width) p.x = 0;
      if(p.x < 0) p.x = confettiCanvas.width;
    }
    requestAnimationFrame(drawConfetti);
  }
  drawConfetti();

  function showMessage(text) {
    msg.textContent = text;
  }

  function resetCueBallPosition(x = cueStartX, y = cueStartY) {
    const cueBall = balls.find(b => b.group === 'cue');
    cueBall.x = x;
    cueBall.y = y;
    cueBall.vx = 0;
    cueBall.vy = 0;
    cueBall.pocketed = false;
    cueBall.updatePosition();
  }

  // Initialize game
  function init() {
    gameOver = false;
    cueBallInHand = false;
    ballsMoving = false;
    pocketedThisShot = [];
    cueBallScratch = false;
    playerGroups = {1: null, 2: null};
    ballsPocketed = {solids: 0, stripes: 0};
    currentPlayer = 1;
    createBalls();
    resetCueBallPosition();
    cueStick.style.display = 'block';
    updateCueStick(0);
    showMessage(`Player 1's turn. Aim and shoot.`);
  }

  // Create balls helper
  function createBalls() {
    balls.forEach(b => b.el.remove());
    balls = [];

    const rect = table.getBoundingClientRect();
    cueStartX = rect.width * 0.4;
    cueStartY = rect.height * 0.6;

    balls.push(new Ball(0, 'cue', 'cue', 0, cueStartX, cueStartY));

    const rackX = rect.width * 0.7;
    const rackY = rect.height * 0.5;
    const rowHeight = BALL_RADIUS * Math.sqrt(3);

    const rackBallsInfo = [
      {number: 1, group: 'solids', color: 'red'},
      {number: 14, group: 'stripes', color: 'blue'},
      {number: 7, group: 'solids', color: 'brown'},
      {number: 9, group: 'stripes', color: 'red'},
      {number: 8, group: 'eight', color: 'eight'},
      {number: 3, group: 'solids', color: 'green'},
      {number: 13, group: 'stripes', color: 'purple'},
      {number: 2, group: 'solids', color: 'yellow'},
      {number: 12, group: 'stripes', color: 'orange'},
      {number: 6, group: 'solids', color: 'blue'},
      {number: 11, group: 'stripes', color: 'green'},
      {number: 5, group: 'solids', color: 'purple'},
      {number: 10, group: 'stripes', color: 'yellow'},
      {number: 4, group: 'solids', color: 'orange'},
      {number: 15, group: 'stripes', color: 'brown'}
    ];

    let ballIndex = 0;
    for (let row = 0; row < 5; row++) {
      const ballsInRow = row + 1;
      const y = rackY + row * rowHeight;
      const rowWidth = ballsInRow * BALL_RADIUS * 2;
      const startX = rackX - rowWidth / 2 + BALL_RADIUS;
      for (let col = 0; col < ballsInRow; col++) {
        if (ballIndex >= rackBallsInfo.length) break;
        const x = startX + col * BALL_RADIUS * 2;
        const info = rackBallsInfo[ballIndex];
        balls.push(new Ball(info.number, info.group, info.color, info.number, x, y));
        ballIndex++;
      }
    }
  }

  // Input event listeners
  table.addEventListener('mousedown', e => {
    if (ballsMoving || gameOver) return;
    if (cueBallInHand) {
      onCueBallPlace(e);
      return;
    }
    const pos = getPointerPos(e);
    const cueBall = balls.find(b => b.group === 'cue');
    if (!cueBall || cueBall.pocketed) return;
    if (dist(pos.x, pos.y, cueBall.x, cueBall.y) <= BALL_RADIUS * 1.5) {
      isAiming = true;
      aimStart = {x: cueBall.x, y: cueBall.y};
      aimCurrent = pos;
      updateAimVisual();
    }
  });
  window.addEventListener('mousemove', e => {
    if (!isAiming) return;
    aimCurrent = getPointerPos(e);
    updateAimVisual();
  });
  window.addEventListener('mouseup', e => {
    if (!isAiming) return;
    isAiming = false;
    clearAimVisual();
    const cueBall = balls.find(b => b.group === 'cue');
    if (!cueBall || cueBall.pocketed) return;

    const dx = aimStart.x - aimCurrent.x;
    const dy = aimStart.y - aimCurrent.y;
    const distance = dist(aimStart.x, aimStart.y, aimCurrent.x, aimCurrent.y);

    if (distance < 5) {
      showMessage(`Drag further to shoot.`);
      updateCueStick(0);
      return;
    }

    const maxPower = 15;
    const power = Math.min(distance / 10, maxPower);
    const angle = Math.atan2(dy, dx);

    shoot(power, angle);
  });

  table.addEventListener('touchstart', e => {
    e.preventDefault();
    if (ballsMoving || gameOver) return;
    if (cueBallInHand) {
      onCueBallPlace(e);
      return;
    }
    const pos = getPointerPos(e);
    const cueBall = balls.find(b => b.group === 'cue');
    if (!cueBall || cueBall.pocketed) return;
    if (dist(pos.x, pos.y, cueBall.x, cueBall.y) <= BALL_RADIUS * 1.5) {
      isAiming = true;
      aimStart = {x: cueBall.x, y: cueBall.y};
      aimCurrent = pos;
      updateAimVisual();
    }
  }, {passive:false});
  window.addEventListener('touchmove', e => {
    e.preventDefault();
    if (!isAiming) return;
    aimCurrent = getPointerPos(e);
    updateAimVisual();
  }, {passive:false});
  window.addEventListener('touchend', e => {
    if (!isAiming) return;
    isAiming = false;
    clearAimVisual();
    const cueBall = balls.find(b => b.group === 'cue');
    if (!cueBall || cueBall.pocketed) return;

    const dx = aimStart.x - aimCurrent.x;
    const dy = aimStart.y - aimCurrent.y;
    const distance = dist(aimStart.x, aimStart.y, aimCurrent.x, aimCurrent.y);

    if (distance < 5) {
      showMessage(`Drag further to shoot.`);
      updateCueStick(0);
      return;
    }

    const maxPower = 15;
    const power = Math.min(distance / 10, maxPower);
    const angle = Math.atan2(dy, dx);

    shoot(power, angle);
  });

  // Game start
  init();
  requestAnimationFrame(gameLoop);
})();
</script>
</body>
</html>
