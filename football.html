<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
<title>8-Ball Pool Game with Turn Controls</title>
<style>
  html, body {
    margin: 0; padding: 0;
    height: 100%;
    background: #18153a;
    display: flex;
    justify-content: center;
    align-items: center;
    user-select: none;
  }
  #game-container {
    position: relative;
    width: 90vw;
    max-width: 600px;
    aspect-ratio: 16 / 9;
    background: linear-gradient(145deg, #3ac6ff 60%, #0d47a1 100%);
    border-radius: 22px;
    border: 7px solid #25c6fc;
    box-shadow: 0 0 30px 8px #2196f3, 0 6px 24px #000a;
    overflow: hidden;
    font-family: Arial, sans-serif;
  }
  #pool-table {
    position: relative;
    width: 100%;
    height: 100%;
  }
  .pocket {
    position: absolute;
    width: 28px; height: 28px;
    border-radius: 50%;
    background: radial-gradient(circle at 60% 40%, #222 60%, #000 100%);
    box-shadow: 0 0 18px #000b, 0 0 0 4px #1b1836;
    z-index: 2;
  }
  .pocket.tl { left: -7px; top: -7px; }
  .pocket.tr { right: -7px; top: -7px; }
  .pocket.bl { left: -7px; bottom: -7px; }
  .pocket.br { right: -7px; bottom: -7px; }
  .pocket.tc { left: 50%; top: -7px; transform: translateX(-50%);}
  .pocket.bc { left: 50%; bottom: -7px; transform: translateX(-50%);}
  #logo {
    position: absolute;
    top: 5%;
    left: 50%;
    transform: translateX(-50%);
    font-family: 'Luckiest Guy', cursive;
    font-size: 2.5rem;
    color: #e0f6ff;
    letter-spacing: 0.6rem;
    text-shadow: 0 3px 10px #0008, 0 1px 0 #2196f3;
    user-select: none;
    pointer-events: none;
    display: flex;
    align-items: center;
    z-index: 3;
  }
  #logo .eight-ball {
    width: 36px;
    height: 36px;
    border-radius: 50%;
    background: radial-gradient(circle at 60% 40%, #444 55%, #111 100%);
    margin: 0 5px;
    box-shadow: 0 0 10px #000a, 0 4px 10px #0008;
    display: flex;
    justify-content: center;
    align-items: center;
    color: white;
    font-weight: bold;
    font-family: Arial, sans-serif;
    font-size: 1.2rem;
    text-shadow: 0 2px 4px #000a;
  }
  .ball {
    position: absolute;
    width: 22px; height: 22px;
    border-radius: 50%;
    box-shadow: 0 2px 8px #000a, 0 0 0 2px #fff3;
    border: 2px solid #fff8;
    z-index: 4;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: bold;
    font-family: Arial, sans-serif;
    user-select: none;
    transition: none;
  }
  .ball.cue { background: radial-gradient(circle at 60% 40%, #fff 80%, #e0e0e0 100%);}
  .ball.eight {
    background: radial-gradient(circle at 60% 40%, #444 70%, #111 100%);
    color: #fff;
    font-size: 1.1rem;
    text-shadow: 0 2px 4px #000a;
  }
  .ball.red { background: radial-gradient(circle at 60% 40%, #ff4b4b 70%, #a60000 100%);}
  .ball.yellow { background: radial-gradient(circle at 60% 40%, #ffe44b 70%, #bba600 100%);}
  .ball.blue { background: radial-gradient(circle at 60% 40%, #4b7bff 70%, #0033a6 100%);}
  .ball.green { background: radial-gradient(circle at 60% 40%, #4bff7b 70%, #00a64b 100%);}
  .ball.purple { background: radial-gradient(circle at 60% 40%, #c44bff 70%, #6a00a6 100%);}
  .ball.orange { background: radial-gradient(circle at 60% 40%, #ffb84b 70%, #a66a00 100%);}
  #cue-stick {
    position: absolute;
    width: 210px;
    height: 7px;
    background: linear-gradient(90deg, #ffb84b 0%, #d48a1b 60%, #333 100%);
    border-radius: 4px;
    box-shadow: 0 2px 8px #000a;
    z-index: 10;
    transform-origin: 30px 50%;
    cursor: pointer;
    user-select: none;
    pointer-events: auto;
    transition: box-shadow 0.15s;
  }
  #cue-stick.disabled {
    pointer-events: none;
    opacity: 0.5;
    cursor: default;
  }
  #cue-stick .cue-tip {
    position: absolute;
    left: 0; top: 1px;
    width: 28px; height: 5px;
    background: linear-gradient(90deg, #eee 60%, #2196f3 100%);
    border-radius: 3px 0 0 3px;
    box-shadow: 1px 0 3px #2196f3;
  }
  #message {
    position: absolute;
    top: 5px;
    width: 100%;
    text-align: center;
    color: #fff;
    font-size: 1.1rem;
    text-shadow: 0 2px 8px #000b;
    z-index: 100;
    pointer-events: none;
  }
  #aimCanvas {
    position: absolute;
    left: 0; top: 0;
    width: 100%; height: 100%;
    pointer-events: none;
    z-index: 20;
  }
  #confetti {
    position: fixed;
    top: 0; left: 0;
    width: 100vw; height: 100vh;
    pointer-events: none;
    z-index: 1000;
  }
  #turn-indicator {
    position: absolute;
    bottom: 10px;
    left: 50%;
    transform: translateX(-50%);
    color: #fff;
    font-size: 1.2rem;
    font-weight: bold;
    text-shadow: 0 2px 6px #000;
    z-index: 100;
    user-select: none;
  }
  #end-turn-btn {
    position: absolute;
    bottom: 50px;
    left: 50%;
    transform: translateX(-50%);
    padding: 8px 16px;
    font-size: 1rem;
    font-weight: bold;
    background: #2196f3;
    color: white;
    border: none;
    border-radius: 8px;
    cursor: pointer;
    box-shadow: 0 2px 8px #0008;
    z-index: 100;
    user-select: none;
  }
  #end-turn-btn:disabled {
    background: #555;
    cursor: default;
  }
  @media (max-width: 500px) {
    #game-container { width: 98vw; aspect-ratio: 16 / 9; }
    #logo { font-size: 1.5rem; letter-spacing: 0.4rem; }
    .ball { width: 18px; height: 18px; font-size: 0.8rem; }
    #cue-stick { width: 160px; height: 5px; }
    #cue-stick .cue-tip { width: 20px; height: 3px; }
    #message { font-size: 0.9rem; }
    #turn-indicator { font-size: 1rem; bottom: 8px; }
    #end-turn-btn { font-size: 0.9rem; padding: 6px 12px; bottom: 40px; }
  }
</style>
</head>
<body>
<div id="game-container">
  <div id="pool-table">
    <div class="pocket tl"></div>
    <div class="pocket tr"></div>
    <div class="pocket bl"></div>
    <div class="pocket br"></div>
    <div class="pocket tc"></div>
    <div class="pocket bc"></div>
    <div id="logo">
      P<span class="eight-ball"><span>8</span></span>OL
    </div>
    <div id="cue-stick"><div class="cue-tip"></div></div>
    <canvas id="aimCanvas"></canvas>
    <div id="message"></div>
    <div id="turn-indicator"></div>
    <button id="end-turn-btn" disabled>End Turn</button>
  </div>
</div>
<canvas id="confetti"></canvas>

<script>
(() => {
  const table = document.getElementById('pool-table');
  const msg = document.getElementById('message');
  const cueStick = document.getElementById('cue-stick');
  const aimCanvas = document.getElementById('aimCanvas');
  const aimCtx = aimCanvas.getContext('2d');
  const confettiCanvas = document.getElementById('confetti');
  const confettiCtx = confettiCanvas.getContext('2d');
  const turnIndicator = document.getElementById('turn-indicator');
  const endTurnBtn = document.getElementById('end-turn-btn');

  const BALL_RADIUS = 11;
  const FRICTION = 0.98;
  const MIN_VELOCITY = 0.05;
  const POCKET_RADIUS = 28;

  // Sound effects
  const collisionSound = new Audio('https://freesound.org/data/previews/66/66717_634166-lq.mp3');
  const pocketSound = new Audio('https://freesound.org/data/previews/146/146726_2615110-lq.mp3');

  let balls = [];
  let currentPlayer = 1;
  let playerGroups = {1: null, 2: null};
  let ballsPocketed = {solids: 0, stripes: 0};
  const ballsPerGroup = 7;
  let gameOver = false;
  let cueBallInHand = false;
  let ballsMoving = false;
  let pocketedThisShot = [];
  let cueBallScratch = false;

  let isAiming = false;
  let aimStart = null;
  let aimCurrent = null;

  function resize() {
    const rect = table.getBoundingClientRect();
    aimCanvas.width = rect.width;
    aimCanvas.height = rect.height;
    aimCanvas.style.width = rect.width + 'px';
    aimCanvas.style.height = rect.height + 'px';

    confettiCanvas.width = window.innerWidth;
    confettiCanvas.height = window.innerHeight;
  }
  window.addEventListener('resize', resize);
  resize();

  function getPocketPositions() {
    const rect = table.getBoundingClientRect();
    return [
      {x: 0, y: 0},
      {x: rect.width / 2, y: 0},
      {x: rect.width, y: 0},
      {x: 0, y: rect.height},
      {x: rect.width / 2, y: rect.height},
      {x: rect.width, y: rect.height}
    ];
  }

  class Ball {
    constructor(id, group, color, number, x, y) {
      this.id = id;
      this.group = group;
      this.color = color;
      this.number = number;
      this.x = x;
      this.y = y;
      this.vx = 0;
      this.vy = 0;
      this.pocketed = false;

      this.el = document.createElement('div');
      this.el.classList.add('ball');
      if (this.group === 'cue') this.el.classList.add('cue');
      else if (this.group === 'eight') this.el.classList.add('eight');
      else this.el.classList.add(this.color);

      if (this.number > 0) this.el.textContent = this.number;

      table.appendChild(this.el);
      this.updatePosition();
    }
    updatePosition() {
      this.el.style.left = (this.x - BALL_RADIUS) + 'px';
      this.el.style.top = (this.y - BALL_RADIUS) + 'px';
      this.el.style.display = this.pocketed ? 'none' : 'flex';
    }
    move() {
      if (this.pocketed) return;
      this.x += this.vx;
      this.y += this.vy;

      const leftBound = BALL_RADIUS;
      const rightBound = table.clientWidth - BALL_RADIUS;
      const topBound = BALL_RADIUS;
      const bottomBound = table.clientHeight - BALL_RADIUS;

      if (this.x < leftBound) {
        this.x = leftBound;
        this.vx = -this.vx * 0.9;
      }
      if (this.x > rightBound) {
        this.x = rightBound;
        this.vx = -this.vx * 0.9;
      }
      if (this.y < topBound) {
        this.y = topBound;
        this.vy = -this.vy * 0.9;
      }
      if (this.y > bottomBound) {
        this.y = bottomBound;
        this.vy = -this.vy * 0.9;
      }

      this.vx *= FRICTION;
      this.vy *= FRICTION;

      if (Math.abs(this.vx) < MIN_VELOCITY) this.vx = 0;
      if (Math.abs(this.vy) < MIN_VELOCITY) this.vy = 0;

      this.updatePosition();
    }
    isMoving() {
      return Math.abs(this.vx) > 0 || Math.abs(this.vy) > 0;
    }
  }

  function dist(x1, y1, x2, y2) {
    return Math.hypot(x1 - x2, y1 - y2);
  }

  function resolveCollision(b1, b2) {
    if (b1.pocketed || b2.pocketed) return;

    const dx = b2.x - b1.x;
    const dy = b2.y - b1.y;
    const distance = Math.hypot(dx, dy);
    if (distance === 0) return;

    if (distance < BALL_RADIUS * 2) {
      const overlap = BALL_RADIUS * 2 - distance;
      const nx = dx / distance;
      const ny = dy / distance;

      b1.x -= nx * overlap / 2;
      b1.y -= ny * overlap / 2;
      b2.x += nx * overlap / 2;
      b2.y += ny * overlap / 2;

      const tx = -ny;
      const ty = nx;

      const v1n = b1.vx * nx + b1.vy * ny;
      const v1t = b1.vx * tx + b1.vy * ty;
      const v2n = b2.vx * nx + b2.vy * ny;
      const v2t = b2.vx * tx + b2.vy * ty;

      const v1nAfter = v2n;
      const v2nAfter = v1n;

      b1.vx = v1nAfter * nx + v1t * tx;
      b1.vy = v1nAfter * ny + v1t * ty;
      b2.vx = v2nAfter * nx + v2t * tx;
      b2.vy = v2nAfter * ny + v2t * ty;

      // Play collision sound
      collisionSound.currentTime = 0;
      collisionSound.play();
    }
  }

  function checkPocket(ball) {
    if (ball.pocketed) return false;
    const pockets = getPocketPositions();
    for (const p of pockets) {
      if (dist(ball.x, ball.y, p.x, p.y) < POCKET_RADIUS) {
        return true;
      }
    }
    return false;
  }

  function pocketBall(ball) {
    ball.pocketed = true;
    ball.vx = 0;
    ball.vy = 0;
    ball.updatePosition();

    // Play pocket sound
    pocketSound.currentTime = 0;
    pocketSound.play();
  }

  function resetCueBallPosition(x, y) {
    const cueBall = balls.find(b => b.group === 'cue');
    cueBall.x = x;
    cueBall.y = y;
    cueBall.vx = 0;
    cueBall.vy = 0;
    cueBall.pocketed = false;
    cueBall.updatePosition();
  }

  function ballsAreMoving() {
    return balls.some(b => b.isMoving());
  }

  function showMessage(text) {
    msg.textContent = text;
  }

  function updateTurnIndicator() {
    if (gameOver) {
      turnIndicator.textContent = "Game Over";
      endTurnBtn.disabled = true;
      cueStick.classList.add('disabled');
      return;
    }
    const group = playerGroups[currentPlayer];
    const groupText = group ? (group.charAt(0).toUpperCase() + group.slice(1)) : "Unassigned";
    turnIndicator.textContent = `Player ${currentPlayer}'s turn â€” ${groupText}`;
    endTurnBtn.disabled = ballsMoving || cueBallInHand;
    cueStick.classList.toggle('disabled', ballsMoving || cueBallInHand);
  }

  function switchTurn() {
    currentPlayer = currentPlayer === 1 ? 2 : 1;
    updateTurnIndicator();
  }

  function enableCueBallPlacement() {
    showMessage(`Player ${currentPlayer}, place the cue ball.`);
    cueStick.style.display = 'none';
    cueBallInHand = true;
    updateTurnIndicator();
  }

  function disableCueBallPlacement() {
    cueBallInHand = false;
    cueStick.style.display = 'block';
    updateTurnIndicator();
  }

  function updateCueStick(angle) {
    const cueBall = balls.find(b => b.group === 'cue');
    if (!cueBall || cueBall.pocketed) return;
    const ballX = cueBall.x;
    const ballY = cueBall.y;
    const gap = BALL_RADIUS * 3.5;
    const stickX = ballX - Math.cos(angle) * gap;
    const stickY = ballY - Math.sin(angle) * gap;
    cueStick.style.left = (stickX - cueStick.offsetWidth * 0.15) + 'px';
    cueStick.style.top = (stickY - cueStick.offsetHeight / 2) + 'px';
    cueStick.style.transform = `rotate(${angle * 180 / Math.PI}deg)`;
  }

  function shoot(power, angle) {
    if (ballsMoving || gameOver || cueBallInHand) return;
    const cueBall = balls.find(b => b.group === 'cue');
    if (!cueBall || cueBall.pocketed) return;
    cueBall.vx = Math.cos(angle) * power;
    cueBall.vy = Math.sin(angle) * power;
    ballsMoving = true;
    pocketedThisShot = [];
    cueBallScratch = false;
    cueStick.style.display = 'none';
    updateTurnIndicator();
  }

  function updateAimVisual() {
    aimCtx.clearRect(0, 0, aimCanvas.width, aimCanvas.height);
    if (!isAiming) return;
    aimCtx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
    aimCtx.lineWidth = 3;
    aimCtx.beginPath();
    aimCtx.moveTo(aimStart.x, aimStart.y);
    aimCtx.lineTo(aimCurrent.x, aimCurrent.y);
    aimCtx.stroke();

    const angle = Math.atan2(aimStart.y - aimCurrent.y, aimStart.x - aimCurrent.x);
    updateCueStick(angle);
  }

  function clearAimVisual() {
    aimCtx.clearRect(0, 0, aimCanvas.width, aimCanvas.height);
  }

  function getPointerPos(e) {
    const rect = table.getBoundingClientRect();
    let clientX, clientY;
    if (e.touches) {
      clientX = e.touches[0].clientX;
      clientY = e.touches[0].clientY;
    } else {
      clientX = e.clientX;
      clientY = e.clientY;
    }
    return {
      x: clientX - rect.left,
      y: clientY - rect.top
    };
  }

  function onPointerDown(e) {
    if (ballsMoving || gameOver) return;
    if (cueBallInHand) {
      onCueBallPlace(e);
      return;
    }
    const pos = getPointerPos(e);
    const cueBall = balls.find(b => b.group === 'cue');
    if (!cueBall || cueBall.pocketed) return;
    if (dist(pos.x, pos.y, cueBall.x, cueBall.y) <= BALL_RADIUS * 1.5) {
      isAiming = true;
      aimStart = {x: cueBall.x, y: cueBall.y};
      aimCurrent = pos;
      updateAimVisual();
    }
  }

  function onPointerMove(e) {
    if (!isAiming) return;
    aimCurrent = getPointerPos(e);
    updateAimVisual();
  }

  function onPointerUp(e) {
    if (!isAiming) return;
    isAiming = false;
    clearAimVisual();
    const cueBall = balls.find(b => b.group === 'cue');
    if (!cueBall || cueBall.pocketed) return;

    const dx = aimStart.x - aimCurrent.x;
    const dy = aimStart.y - aimCurrent.y;
    const distance = dist(aimStart.x, aimStart.y, aimCurrent.x, aimCurrent.y);

    if (distance < 5) {
      showMessage(`Drag further to shoot.`);
      updateCueStick(0);
      return;
    }

    const maxPower = 15;
    const power = Math.min(distance / 10, maxPower);
    const angle = Math.atan2(dy, dx);

    shoot(power, angle);
  }

  function onCueBallPlace(e) {
    if (!cueBallInHand) return;
    const pos = getPointerPos(e);
    const leftBound = BALL_RADIUS;
    const rightBound = table.clientWidth - BALL_RADIUS;
    const topBound = BALL_RADIUS;
    const bottomBound = table.clientHeight - BALL_RADIUS;
    let x = Math.min(Math.max(pos.x, leftBound), rightBound);
    let y = Math.min(Math.max(pos.y, topBound), bottomBound);
    resetCueBallPosition(x, y);
    disableCueBallPlacement();
    showMessage(`Player ${currentPlayer}'s turn. Aim and shoot.`);
    updateCueStick(0);
  }

  function onShotEnd() {
    ballsMoving = false;

    if (pocketedThisShot.length === 0 && !cueBallScratch) {
      switchTurn();
      showMessage(`Player ${currentPlayer}'s turn`);
    } else {
      if (cueBallScratch) {
        switchTurn();
        cueBallInHand = true;
        enableCueBallPlacement();
        showMessage(`Foul! Player ${currentPlayer} scratched. Player ${currentPlayer === 1 ? 2 : 1} ball in hand.`);
      } else {
        if (!playerGroups[currentPlayer]) {
          const firstBall = pocketedThisShot.find(b => b.group === 'solids' || b.group === 'stripes');
          if (firstBall) {
            playerGroups[currentPlayer] = firstBall.group;
            playerGroups[currentPlayer === 1 ? 2 : 1] = firstBall.group === 'solids' ? 'stripes' : 'solids';
            showMessage(`Player ${currentPlayer} is ${playerGroups[currentPlayer]}. Player ${currentPlayer === 1 ? 2 : 1} is ${playerGroups[currentPlayer === 1 ? 2 : 1]}. Player ${currentPlayer} continues.`);
          }
        }

        let pocketedOwnGroup = false;
        for (const ball of pocketedThisShot) {
          if (ball.group === playerGroups[currentPlayer]) {
            ballsPocketed[ball.group]++;
            pocketedOwnGroup = true;
          }
          if (ball.group === 'eight') {
            if (ballsPocketed[playerGroups[currentPlayer]] === ballsPerGroup) {
              gameOver = true;
              showMessage(`Player ${currentPlayer} wins! ðŸŽ‰`);
              cueStick.style.display = 'none';
              startConfetti();
              endTurnBtn.disabled = true;
              return;
            } else {
              gameOver = true;
              showMessage(`Player ${currentPlayer} lost by pocketing 8-ball too early.`);
              cueStick.style.display = 'none';
              endTurnBtn.disabled = true;
              return;
            }
          }
        }

        if (pocketedOwnGroup) {
          showMessage(`Player ${currentPlayer} continues.`);
        } else {
          switchTurn();
          showMessage(`Player ${currentPlayer}'s turn.`);
        }
      }
    }

    pocketedThisShot = [];
    cueBallScratch = false;
    if (!gameOver && !cueBallInHand) cueStick.style.display = 'block';
    updateTurnIndicator();
  }

  function gameLoop() {
    if (!ballsMoving) {
      requestAnimationFrame(gameLoop);
      return;
    }

    balls.forEach(b => b.move());

    for (let i = 0; i < balls.length; i++) {
      for (let j = i + 1; j < balls.length; j++) {
        resolveCollision(balls[i], balls[j]);
      }
    }

    balls.forEach(ball => {
      if (!ball.pocketed && checkPocket(ball)) {
        pocketBall(ball);
        pocketedThisShot.push(ball);
        if (ball.group === 'cue') cueBallScratch = true;
      }
    });

    if (!ballsAreMoving()) {
      onShotEnd();
      if (!cueBallInHand && !gameOver) cueStick.style.display = 'block';
    }

    requestAnimationFrame(gameLoop);
  }

  // Confetti effect
  let confettiPieces = [];
  let confettiActive = false;
  function startConfetti() {
    confettiActive = true;
    createConfetti();
  }
  function createConfetti() {
    confettiPieces = [];
    for(let i=0;i<100;i++) {
      confettiPieces.push({
        x: Math.random()*confettiCanvas.width,
        y: Math.random()*confettiCanvas.height,
        r: Math.random()*6+4,
        c: `hsl(${Math.random()*360}, 100%, 70%)`,
        s: Math.random()*3+1,
        d: Math.random()*2*Math.PI
      });
    }
  }
  function drawConfetti() {
    confettiCtx.clearRect(0, 0, confettiCanvas.width, confettiCanvas.height);
    if (!confettiActive) return;
    for(let p of confettiPieces) {
      confettiCtx.save();
      confettiCtx.translate(p.x,p.y);
      confettiCtx.rotate(p.d);
      confettiCtx.fillStyle = p.c;
      confettiCtx.beginPath();
      confettiCtx.arc(0,0,p.r,0,2*Math.PI);
      confettiCtx.fill();
      confettiCtx.restore();
      p.y += p.s;
      p.x += Math.sin(p.d)*1.5;
      if(p.y > confettiCanvas.height) p.y = -10;
      if(p.x > confettiCanvas.width) p.x = 0;
      if(p.x < 0) p.x = confettiCanvas.width;
    }
    requestAnimationFrame(drawConfetti);
  }
  drawConfetti();

  // Initialize balls and rack them properly
  function initBalls() {
    balls.forEach(b => b.el.remove());
    balls = [];

    const rect = table.getBoundingClientRect();
    const cueStartX = rect.width * 0.4;
    const cueStartY = rect.height * 0.6;

    balls.push(new Ball(0, 'cue', 'cue', 0, cueStartX, cueStartY));

    const rackX = rect.width * 0.7;
    const rackY = rect.height * 0.5;
    const ballDiameter = BALL_RADIUS * 2;
    const rowHeight = Math.sqrt(3) * BALL_RADIUS;

    // Balls order for rack
    const rackBallsInfo = [
      {number: 1, group: 'solids', color: 'red'},
      {number: 14, group: 'stripes', color: 'blue'},
      {number: 7, group: 'solids', color: 'brown'},
      {number: 9, group: 'stripes', color: 'red'},
      {number: 8, group: 'eight', color: 'eight'},
      {number: 3, group: 'solids', color: 'green'},
      {number: 13, group: 'stripes', color: 'purple'},
      {number: 2, group: 'solids', color: 'yellow'},
      {number: 12, group: 'stripes', color: 'orange'},
      {number: 6, group: 'solids', color: 'blue'},
      {number: 11, group: 'stripes', color: 'green'},
      {number: 5, group: 'solids', color: 'purple'},
      {number: 10, group: 'stripes', color: 'yellow'},
      {number: 4, group: 'solids', color: 'orange'},
      {number: 15, group: 'stripes', color: 'brown'}
    ];

    // Positions for 15 balls in triangle
    const positions = [];
    for (let row = 0; row < 5; row++) {
      const ballsInRow = row + 1;
      const y = rackY + row * rowHeight;
      const rowWidth = ballsInRow * ballDiameter;
      const startX = rackX - rowWidth / 2 + BALL_RADIUS;
      for (let i = 0; i < ballsInRow; i++) {
        positions.push({x: startX + i * ballDiameter, y: y});
      }
    }

    // Place 8-ball in center (index 5)
    const eightBallIndex = 5;
    const eightBall = rackBallsInfo.find(b => b.number === 8);
    rackBallsInfo.splice(rackBallsInfo.indexOf(eightBall), 1);
    rackBallsInfo.splice(eightBallIndex, 0, eightBall);

    // Place one solid and one stripe in rear corners (indices 10 and 14)
    const solidBall = rackBallsInfo.find(b => b.group === 'solids' && b.number !== 8);
    const stripeBall = rackBallsInfo.find(b => b.group === 'stripes' && b.number !== 8);
    [rackBallsInfo[10], rackBallsInfo[rackBallsInfo.indexOf(solidBall)]] = [solidBall, rackBallsInfo[10]];
    [rackBallsInfo[14], rackBallsInfo[rackBallsInfo.indexOf(stripeBall)]] = [stripeBall, rackBallsInfo[14]];

    // Create ball objects and assign positions
    rackBallsInfo.forEach((info, i) => {
      const ball = new Ball(info.number, info.group, info.color, info.number, positions[i].x, positions[i].y);
      balls.push(ball);
    });
  }

  function init() {
    gameOver = false;
    cueBallInHand = false;
    ballsMoving = false;
    pocketedThisShot = [];
    cueBallScratch = false;
    playerGroups = {1: null, 2: null};
    ballsPocketed = {solids: 0, stripes: 0};
    currentPlayer = 1;
    initBalls();
    const rect = table.getBoundingClientRect();
    resetCueBallPosition(rect.width * 0.4, rect.height * 0.6);
    cueStick.style.display = 'block';
    updateCueStick(0);
    showMessage(`Player 1's turn. Aim and shoot.`);
    updateTurnIndicator();
  }

  // Manual End Turn Button
  endTurnBtn.addEventListener('click', () => {
    if (ballsMoving || cueBallInHand || gameOver) return;
    switchTurn();
    showMessage(`Player ${currentPlayer}'s turn.`);
    updateTurnIndicator();
  });

  init();
  requestAnimationFrame(gameLoop);

  table.addEventListener('mousedown', onPointerDown);
  window.addEventListener('mousemove', onPointerMove);
  window.addEventListener('mouseup', onPointerUp);
  table.addEventListener('touchstart', e => { e.preventDefault(); onPointerDown(e); }, {passive:false});
  window.addEventListener('touchmove', e => { e.preventDefault(); if(isAiming){ aimCurrent = getPointerPos(e); updateAimVisual(); } }, {passive:false});
  window.addEventListener('touchend', e => { if(isAiming){ isAiming = false; clearAimVisual(); onPointerUp(e); } });
})();
</script>
</body>
</html>
